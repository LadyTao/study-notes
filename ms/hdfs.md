##### 1. Hadoop架构
* NameNode。管理文件系统的元数据和命名空间，文件与block的映射，block与DN的映射；与客户端交互。
* DataNode。管理文件块，每个文件快可以以副本的形式存在于多个节点上；启动时以及定期向NN汇报信息。响应客户端读写操作；响应NN的指令，如删除、创建、复制数据块等。
* Secondary NameNode。监控NN的后台辅助程序，定期获取元数据快照。高可用模式下不需要。
* Journal Node。高可用模式下需要启动，它会监控edits文件的变化并同步一份，standby的NN会及时从这里同步获取最新的edits数据。
##### 2. NN的高可用如何保障，联邦机制是什么？
hdfs通过引入多个NN，其中一个是active状态提供对外的访问和对内的管理，剩余的NN为stabdby状态，平时只负责同步活跃状态NN的元数据edits，并生成fsimage文件。一旦active的NN挂掉后，它可以立即切换为活跃状态，接管集群。所以这种模式下会有脑裂问题，HDFS提供三种隔离机制解决这个问题：
* 共享存储隔离：同一时刻只允许一个NN向journalNode写edits数据;
* 客户端隔离：同一时刻只允许一个NN响应客户端请求；
* DataNode隔离：同一时刻只允许一个NN向DN下发指令。
联邦机制与高可用不一样。高可用解决的是单个NN的高可用问题，联邦机制解决的是单个NN容量限制的问题。因为即使是高可用模式下，同一时刻也还是只有一个NN节点负责整个集群的元数据和命名空间管理，集群规模越大，单点存在性能问题。联邦机制将集群划分给不同的NN管理，这些NN彼此的元数据和命名空间不交叉不影响。

##### 3. 文件写入流程和读取流程
* **读过程**：
HDFS的读操作有三个层次：
1: 网络读：最基本的方式，客户端与DN通过socket链接传输数据；
2: 短路读：当客户端与DN同属一个物理节点时，客户端可以直接打开数据副本，无需DN转发；
3: 零拷贝读：客户端与缓存的数据块DN在同一个物理节点时，客户端通过零拷贝方式读取数据块（缓存的数据在内存，且无序校验），效率最高。
> 1. 客户端调用open接口，与NN沟通，打开文件
> 2. nn返回文件的起始块给客户端，客户端调用read读取文件
> 3. 客户端与最近的可用的dn建立连接，反复调用read方法，将数据传送到客户端。
> 4. 当读到文件末尾时，寻找下一个最佳节点
> 5. 读取完毕，关闭连接
>注意点： 
>1：每次需要读新的block时，都需要跟NN沟通。NN会返回一个排序好的DN列表，客户端优先选择列表最前的那个节点
>2：客户端是并行度数据的，同时读取多个块
>3：读的时候有buffer缓存
>4：当读的时候出现异常，会向NN汇报信息，进行尝试。如果还是失败就切换其他节点读数据。

* **写过程**：
> 1. 客户端调用cerate创建新文件。
> 2. 与NN沟通，在命名空间中记录新文件，NN返回客户端信息，允许写入。
> 3. 客户端调用write方法写入数据。
> 4. 数据切分为一个个packet包，写入一个内部队列。
> 5. 当packet写成功后，发送确认消息(ackQuene)，队列中删除对应的包。
> 6. 完全写入，关闭连接。


##### 4. fsimage和edits文件的作用
fsimage文件保存了文件系统目录树中每一个文件或目录的信息，包括名称、大小、用户、用户组、创建时间、修改时间等信息。每当NN启动，它就会加载最新的fsimage文件重构命名空间。但是这个文件一般都特别大，直接从NN dump一次会非常耗时，而hdfs的文件又在不断地变化，这导致fsimage文件根本不可能追踪到最新的元数据，而一旦NN宕机，则很可能丢失数据。为了解决这个问题，引入了edits文件。
edits文件保存了最近一段时间内对于文件的所有操作，包括：新增、删除、修改。每一次对文件命名空间修改，会产生一个transactionID记录这个操作。在高可用模式下，journal node会把edits文件保存起来，非高可用模式下，由secondary namenode定期拉取。edits文件被拉取后并与之前旧的fsimage文件合并，并产生最新的fsimage文件，并发送给active状态的NN。

##### 5. 租约机制，有什么作用
hdfs文件是一次写入多次读取的，且写的过程不允许并行写入，这个机制的实现靠的就是租约。租约是NN赋予客户端的一个合同，允许其在规定的时间内有写入文件的权限。
当客户端获取到租约后，便拥有了此文件的独占权限，其他客户端无法打开进行操作。租约会过期，过期后会被强制收回，但是客户端可以进行续约以延长使用。
